{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Comparison of Machine Learning Algorithms with Microbiome dataset\n",
    "## Brian Nohomovich and Nat Hawkins\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Code Overview\n",
    "\n",
    "1. imports the microbiome and clinical data\n",
    "2. normalizes the microbiome data with log-transformation and Z-score (a standard appraoch)\n",
    "3. performs a Random Forest Classifier, Linear Support Vector Machine, Logistic Regression, Kmeans\n",
    "4. Calculates AUC of above 4 methods"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Importing necessary libraries\n"
     ]
    }
   ],
   "source": [
    "##Imports\n",
    "print(\"Importing necessary libraries\")\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import pandas as pd\n",
    "import random\n",
    "from scipy.stats import zscore\n",
    "import itertools"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "##Sklearn Imports\n",
    "from sklearn.ensemble import RandomForestClassifier as RFC\n",
    "from sklearn.multiclass import OneVsRestClassifier\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "from sklearn.cluster import KMeans\n",
    "from sklearn.metrics import adjusted_rand_score\n",
    "from sklearn.decomposition import PCA\n",
    "from sklearn.metrics import auc, roc_curve\n",
    "from sklearn import svm\n",
    "from sklearn.model_selection import train_test_split as TTS\n",
    "from sklearn.preprocessing import label_binarize\n",
    "from sklearn.metrics import classification_report, confusion_matrix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "##########################################################\n",
    "##Print Message Function and Plot Confusion Matrix\n",
    "##########################################################\n",
    "def print_message(string):\n",
    "    print('#'*(len(string) + 2))\n",
    "    print('#'+string+'#')\n",
    "    print('#'*(len(string) + 2))\n",
    "\n",
    "##From sklearn\n",
    "##http://scikit-learn.org/stable/auto_examples/model_selection/plot_confusion_matrix.html\n",
    "def plot_confusion_matrix(cm, classes,\n",
    "                          normalize=False,\n",
    "                          title='Confusion matrix',\n",
    "                          cmap=plt.cm.Blues, fname = \"\"):\n",
    "    \"\"\"\n",
    "    This function prints and plots the confusion matrix.\n",
    "    Normalization can be applied by setting `normalize=True`.\n",
    "    \"\"\"\n",
    "    if normalize:\n",
    "        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]\n",
    "        print(\"Normalized confusion matrix\")\n",
    "    else:\n",
    "        print('Confusion matrix, without normalization')\n",
    "\n",
    "    plt.figure()\n",
    "    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n",
    "    plt.title(title)\n",
    "    plt.colorbar()\n",
    "    tick_marks = np.arange(len(classes))\n",
    "    plt.xticks(tick_marks, classes, rotation=45)\n",
    "    plt.yticks(tick_marks, classes)\n",
    "\n",
    "    fmt = '.2f' if normalize else 'd'\n",
    "    thresh = cm.max() / 2.\n",
    "    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n",
    "        plt.text(j, i, format(cm[i, j], fmt),\n",
    "                 horizontalalignment=\"center\",\n",
    "                 color=\"white\" if cm[i, j] > thresh else \"black\")\n",
    "\n",
    "    plt.ylabel('True label')\n",
    "    plt.xlabel('Predicted label')\n",
    "    plt.tight_layout()\n",
    "    plt.savefig(fname)\n",
    "##########################################################"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "\n",
      "Loading in the Data\n",
      "Transforming classes into integers for the model\n",
      "Getting the bacterial/viral counts from the data and clinical symptoms\n",
      "\n",
      "Getting feature names from data\n",
      "#########################\n",
      "#Data Loaded and Ready!!#\n",
      "#########################\n",
      "\n",
      "\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\bnoho\\Anaconda3\\lib\\site-packages\\ipykernel_launcher.py:39: RuntimeWarning: divide by zero encountered in log2\n"
     ]
    }
   ],
   "source": [
    "##########################################################\n",
    "##Loading, Concaetnating, and Cleaning the Data for Analysis\n",
    "##########################################################\n",
    "\n",
    "##Load in data\n",
    "print(\"\\n\\nLoading in the Data\")\n",
    "# data_df = pd.read_csv(\"full_data.csv\")\n",
    "data_df = pd.read_csv(\"full_data.csv\") ##Local Development Copy\n",
    "\n",
    "##Extract Class Predictions and make them discrete integers\n",
    "print(\"Transforming classes into integers for the model\")\n",
    "labels = data_df['Health'].values\n",
    "unique_labs = np.unique(labels)\n",
    "y_true = []\n",
    "for i in labels:\n",
    "    y_true.append([j for j in range(len(unique_labs)) if unique_labs[j] == i][0])\n",
    "\n",
    "##Extract the indices for the tags for the bacterial/viral data\n",
    "print(\"Getting the bacterial/viral counts from the data and clinical symptoms\\n\")\n",
    "first_tag = 'Bacteroidetes'\n",
    "last_tag = 'Virus'\n",
    "first_loc = [x for x in range(len(data_df.columns)) if data_df.columns[x] == first_tag][0]\n",
    "last_loc = [x+1 for x in range(len(data_df.columns)) if data_df.columns[x] == last_tag][0]\n",
    "\n",
    "##Get the names of those features from the data\n",
    "print(\"Getting feature names from data\")\n",
    "micro_bio_colums = data_df.columns[first_loc:last_loc]\n",
    "\n",
    "##Getting the clinical columns\n",
    "first_tag = 'No Symptoms'\n",
    "last_tag = 'Fever'\n",
    "first_loc = [x for x in range(len(data_df.columns)) if data_df.columns[x] == first_tag][0]\n",
    "last_loc = [x+1 for x in range(len(data_df.columns)) if data_df.columns[x] == last_tag][0]\n",
    "clinical_columns = data_df.columns[first_loc:last_loc]\n",
    "\n",
    "##Extract the matrix of expression data and normalize\n",
    "##Log2 transform and the z-score normalization\n",
    "micro_bio_data = data_df[micro_bio_colums].values.astype(float)\n",
    "micro_bio_data = np.log2(micro_bio_data)\n",
    "micro_bio_data[np.isnan(micro_bio_data)] = 0\n",
    "micro_bio_data[np.isinf(micro_bio_data)] = 0\n",
    "micro_bio_data = zscore(micro_bio_data, axis = 1)\n",
    "micro_bio_data[np.isnan(micro_bio_data)] = 0\n",
    "clincal_data = data_df[clinical_columns].values.astype(float)\n",
    "\n",
    "##Total Features\n",
    "features = np.array(list(clinical_columns)+list(micro_bio_colums))\n",
    "\n",
    "##Final Model Data\n",
    "X = np.concatenate((clincal_data,micro_bio_data), axis = 1)\n",
    "y = y_true\n",
    "\n",
    "print_message(\"Data Loaded and Ready!!\")\n",
    "##########################################################\n",
    "##########################################################\n",
    "\n",
    "print('\\n')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style>\n",
       "    .dataframe thead tr:only-child th {\n",
       "        text-align: right;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: left;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Sample ID</th>\n",
       "      <th>Health</th>\n",
       "      <th>No Symptoms</th>\n",
       "      <th>Abdominal Pain</th>\n",
       "      <th>Body Ache</th>\n",
       "      <th>Diarrhea</th>\n",
       "      <th>Diarrhea w/Blood</th>\n",
       "      <th>Chills</th>\n",
       "      <th>Fatigue</th>\n",
       "      <th>Headache</th>\n",
       "      <th>...</th>\n",
       "      <th>Dictyoglomi</th>\n",
       "      <th>Elusimicrobia</th>\n",
       "      <th>Deferribacteres</th>\n",
       "      <th>Chrysiogenetes</th>\n",
       "      <th>Gemmatimonadetes</th>\n",
       "      <th>Armatimonadetes</th>\n",
       "      <th>Candidatus Saccharibacteria</th>\n",
       "      <th>Thermodesulfobacteria</th>\n",
       "      <th>Caldiserica</th>\n",
       "      <th>Virus</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>1</td>\n",
       "      <td>Case</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>...</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>2620</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>2</td>\n",
       "      <td>Case</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>...</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>442</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>4</td>\n",
       "      <td>Case</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>...</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>433</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>6</td>\n",
       "      <td>Control</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>...</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>2537</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>7</td>\n",
       "      <td>Follow</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>...</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>2007</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>5 rows Ã— 47 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "   Sample ID   Health  No Symptoms  Abdominal Pain  Body Ache  Diarrhea  \\\n",
       "0          1     Case            0               0          0         1   \n",
       "1          2     Case            0               1          0         1   \n",
       "2          4     Case            0               1          0         1   \n",
       "3          6  Control            0               0          0         1   \n",
       "4          7   Follow            1               0          0         0   \n",
       "\n",
       "   Diarrhea w/Blood  Chills  Fatigue  Headache  ...    Dictyoglomi  \\\n",
       "0                 0       0        0         0  ...              0   \n",
       "1                 1       1        1         0  ...              0   \n",
       "2                 1       0        0         0  ...              0   \n",
       "3                 0       0        0         0  ...              0   \n",
       "4                 0       0        0         0  ...              0   \n",
       "\n",
       "   Elusimicrobia  Deferribacteres  Chrysiogenetes  Gemmatimonadetes  \\\n",
       "0              0                0               0                 0   \n",
       "1              0                0               0                 0   \n",
       "2              0                0               0                 0   \n",
       "3              0                0               0                 0   \n",
       "4              0                0               0                 0   \n",
       "\n",
       "   Armatimonadetes  Candidatus Saccharibacteria  Thermodesulfobacteria  \\\n",
       "0                0                            0                      0   \n",
       "1                0                            0                      0   \n",
       "2                0                            0                      0   \n",
       "3                0                            0                      0   \n",
       "4                0                            0                      0   \n",
       "\n",
       "   Caldiserica  Virus  \n",
       "0            0   2620  \n",
       "1            0    442  \n",
       "2            0    433  \n",
       "3            0   2537  \n",
       "4            0   2007  \n",
       "\n",
       "[5 rows x 47 columns]"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#check dataframe\n",
    "data_df.head(5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "################\n",
      "#Working on RFC#\n",
      "################\n",
      "Confusion matrix, without normalization\n",
      "[[15  1  2]\n",
      " [ 1 25  1]\n",
      " [ 1  4  4]]\n",
      "             precision    recall  f1-score   support\n",
      "\n",
      "          0       0.88      0.83      0.86        18\n",
      "          1       0.83      0.93      0.88        27\n",
      "          2       0.57      0.44      0.50         9\n",
      "\n",
      "avg / total       0.81      0.81      0.81        54\n",
      "\n",
      "##########################\n",
      "#Random Forest Classifier#\n",
      "##########################\n",
      "\n",
      "After 20 Trials:\n",
      "AUC Case: 0.9221\n",
      "AUC Control: 0.8316\n",
      "AUC Follow: 0.7784\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "##########################################################\n",
    "##Random Forest Classifier\n",
    "##########################################################\n",
    "\n",
    "##Make dictionary to store model importances\n",
    "print_message(\"Working on RFC\")\n",
    "\n",
    "model_importances = {}\n",
    "for feature in list(clinical_columns)+list(micro_bio_colums):\n",
    "    model_importances[feature] = 0\n",
    "\n",
    "##Store AUC for CV\n",
    "auc_validations = {}\n",
    "for k in np.unique(y_true):\n",
    "    auc_validations[k] = []\n",
    "\n",
    "##K-fold Cross Validation\n",
    "for T in range(20):\n",
    "    ##Train-Test Split\n",
    "    X_train, X_test, y_train, y_test = TTS(X, y, test_size = 0.25)\n",
    "\n",
    "    ##Train the Model\n",
    "    # print(\"Building RFC model\\n\")\n",
    "    rfc = RFC(n_estimators=30, n_jobs = 5)\n",
    "    rfc.fit(X_train, y_train)\n",
    "    y_pred = rfc.predict_proba(X_test)\n",
    "    y_pred_b = rfc.predict(X_test)\n",
    "\n",
    "    ##Create encoding for AUC\n",
    "    y_test_e = label_binarize(y_test, classes = np.unique(y_test))\n",
    "\n",
    "    # Compute ROC Curve and AUC for each class\n",
    "    fpr = dict()\n",
    "    tpr = dict()\n",
    "    roc_auc = dict()\n",
    "    for i in range(y_test_e.shape[1]):\n",
    "        fpr[i], tpr[i], _ = roc_curve(y_test_e[:, i], y_pred[:, i])\n",
    "        roc_auc[i] = auc(fpr[i], tpr[i])\n",
    "    for k in roc_auc.keys():\n",
    "        auc_validations[k].append(roc_auc[k])\n",
    "\n",
    "\n",
    "    ##Extract Feature Importances\n",
    "    importances = rfc.feature_importances_\n",
    "    sorted_inds = np.argsort(importances)[::-1]\n",
    "    sorted_features = features[sorted_inds]\n",
    "    sorted_importances = importances[sorted_inds]\n",
    "\n",
    "    for i,val in enumerate(sorted_features):\n",
    "        model_importances[val] += sorted_importances[i]\n",
    "\n",
    "    if T==19:\n",
    "        rfc = plot_confusion_matrix(confusion_matrix(y_test, y_pred_b), classes = [\"Sick\", \"Healthy\", \"Follow\"], fname = r\"results/random_forest.png\")\n",
    "        print(confusion_matrix(y_test, y_pred_b))\n",
    "        print(classification_report(y_test, y_pred_b))\n",
    "\n",
    "\n",
    "##Print Results for Random Forest\n",
    "print_message(\"Random Forest Classifier\")\n",
    "print('\\n'+\"After {} Trials:\".format(T+1))\n",
    "for k in auc_validations.keys():\n",
    "    print(\"AUC {}: {}\".format(unique_labs[k], round(np.mean(auc_validations[k]),4)))\n",
    "\n",
    "##Final Feature Importances Plot\n",
    "importances = np.array(list(model_importances.values()))\n",
    "sorted_inds = np.argsort(importances)[::-1]\n",
    "sorted_importances = importances[sorted_inds]/len(importances)\n",
    "features = np.array(list(model_importances.keys()))\n",
    "sorted_features = features[sorted_inds]\n",
    "plt.figure(figsize=(13, 7))\n",
    "ax = plt.gca()\n",
    "ax.bar(range(len(sorted_inds)), sorted_importances)\n",
    "ax.set_title(\"Feature Importances\", fontsize = 23)\n",
    "ax.set_ylabel(\"Feature Importances\", fontsize = 16)\n",
    "ax.set_xlabel(\"Feature\", fontsize = 16)\n",
    "ax.set_xticks(range(len(sorted_inds)))\n",
    "ax.set_xticklabels(sorted_features, rotation = 90)\n",
    "plt.tight_layout()\n",
    "plt.savefig(r\"results/full_w_clinical_importances.png\", dpi = 200, bbox_inches = 'tight')\n",
    "\n",
    "to_save = np.array(importances)\n",
    "np.savetxt(r\"results/importances_in_order_of_features.txt\", to_save)\n",
    "\n",
    "##########################################################\n",
    "\n",
    "print('\\n')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Figure 1, Feature Importances](results/full_w_clinical_importances.png)\n",
    "\n",
    "#### Figure 1. Feature Importances as determined by Random Forest Classifier.\n",
    "\n",
    "This figure identifies Fever, Proteobacteria and No Symptoms as the top 3 most important features. Fever and Proteobacteria abundance elevation was present in the vast majority of cases. No symptoms was present in most of the controls but not in the follow-up. The No symptom feature is probably how the classified distinguishes follow-up from control states."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Figure 2, Confusion  Matrix](results/random_forest.png)\n",
    "\n",
    "#### Figure 2. Confusion Matrix of Random Forest Classifier results.\n",
    "\n",
    "This figure identifies the samples in the test set and identifies their predicted and real values. For instance, their are 27 \"Healthy\" samples in the test dataset. 25 of them are predicted correctly and 2 are predicted wrong (predicted as 1 sick and 1 follow-up). "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "##########################################\n",
      "#Working on Linear Support Vector Machine#\n",
      "##########################################\n",
      "Confusion matrix, without normalization\n",
      "[[13  1  1]\n",
      " [ 1 25  2]\n",
      " [ 0  4  7]]\n",
      "             precision    recall  f1-score   support\n",
      "\n",
      "          0       0.93      0.87      0.90        15\n",
      "          1       0.83      0.89      0.86        28\n",
      "          2       0.70      0.64      0.67        11\n",
      "\n",
      "avg / total       0.83      0.83      0.83        54\n",
      "\n",
      "############\n",
      "#Linear SVM#\n",
      "############\n",
      "\n",
      "After 20 Trials:\n",
      "AUC Case: 0.95\n",
      "AUC Control: 0.8793\n",
      "AUC Follow: 0.8378\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "##########################################################\n",
    "##Linear SVM\n",
    "##########################################################\n",
    "print_message(\"Working on Linear Support Vector Machine\")\n",
    "\n",
    "##Store AUC for CV\n",
    "auc_validations = {}\n",
    "for k in np.unique(y_true):\n",
    "    auc_validations[k] = []\n",
    "\n",
    "##Cross Validation by Repeat Trials\n",
    "for T in range(20):\n",
    "    # print(\"Trial {}\".format(T+1))\n",
    "    ##Train-Test Split\n",
    "    X_train, X_test, y_train, y_test = TTS(X, y, test_size = 0.25)\n",
    "\n",
    "    ##Train the Model\n",
    "    classifier = OneVsRestClassifier(svm.SVC(kernel='linear', probability=True))\n",
    "    classifier.fit(X_train, y_train)\n",
    "\n",
    "    y_pred = classifier.predict_proba(X_test)\n",
    "    y_pred_b = classifier.predict(X_test)\n",
    "\n",
    "    ##Create encoding for AUC\n",
    "    y_test_e = label_binarize(y_test, classes = np.unique(y_true))\n",
    "\n",
    "    # Compute ROC Curve and AUC for each class\n",
    "    fpr = dict()\n",
    "    tpr = dict()\n",
    "    roc_auc = dict()\n",
    "    for i in range(y_test_e.shape[1]):\n",
    "        fpr[i], tpr[i], _ = roc_curve(y_test_e[:,i], y_pred[:,i])\n",
    "        roc_auc[i] = auc(fpr[i], tpr[i])\n",
    "    for k in roc_auc.keys():\n",
    "        auc_validations[k].append(roc_auc[k])\n",
    "\n",
    "    if T==19:\n",
    "        lin_reg = plot_confusion_matrix(confusion_matrix(y_test, y_pred_b), classes = [\"Sick\", \"Healthy\", \"Follow\"], fname = r\"results/lin_svm.png\")\n",
    "        print(confusion_matrix(y_test, y_pred_b))\n",
    "        print(classification_report(y_test, y_pred_b))\n",
    "\n",
    "##Print Results\n",
    "print_message(\"Linear SVM\")\n",
    "print('\\n'+\"After {} Trials:\".format(T+1))\n",
    "for k in auc_validations.keys():\n",
    "    print(\"AUC {}: {}\".format(unique_labs[k], round(np.mean(auc_validations[k]),4)))\n",
    "\n",
    "##########################################################\n",
    "\n",
    "print('\\n')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Figure 3, Confusion Matrix](results/lin_svm.png)\n",
    "\n",
    "#### Figure 3. Confusion Matrix of Linear Support Vector Machine.\n",
    "\n",
    "This figure identifies the samples in the test set and identifies their predicted and real values. For instance, their are 15 \"Sick\" samples in the test dataset. 13 of them are predicted correctly and 2 are predicted wrong (predicted as 1 healthy and 1 follow-up). "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "################################\n",
      "#Working on Logistic Regression#\n",
      "################################\n",
      "Confusion matrix, without normalization\n",
      "[[13  1  2]\n",
      " [ 1 18  5]\n",
      " [ 0  1 13]]\n",
      "             precision    recall  f1-score   support\n",
      "\n",
      "          0       0.93      0.81      0.87        16\n",
      "          1       0.90      0.75      0.82        24\n",
      "          2       0.65      0.93      0.76        14\n",
      "\n",
      "avg / total       0.84      0.81      0.82        54\n",
      "\n",
      "#####################\n",
      "#Logistic Regression#\n",
      "#####################\n",
      "\n",
      "After 20 Trials:\n",
      "AUC Case: 0.9525\n",
      "AUC Control: 0.8819\n",
      "AUC Follow: 0.8503\n"
     ]
    }
   ],
   "source": [
    "##########################################################\n",
    "##Logistic Regression\n",
    "##########################################################\n",
    "print_message(\"Working on Logistic Regression\")\n",
    "\n",
    "##Store AUC for CV\n",
    "auc_validations = {}\n",
    "for k in np.unique(y_true):\n",
    "    auc_validations[k] = []\n",
    "\n",
    "##Cross Validation by Repeat Trials\n",
    "for T in range(20):\n",
    "    ##Train-Test Split\n",
    "    X_train, X_test, y_train, y_test = TTS(X, y, test_size = 0.25)\n",
    "\n",
    "    ##Train the Model\n",
    "    classifier = LogisticRegression()\n",
    "    classifier.fit(X_train, y_train)\n",
    "\n",
    "    y_pred = classifier.predict_proba(X_test)\n",
    "    y_pred_b = classifier.predict(X_test)\n",
    "\n",
    "    ##Create encoding for AUC\n",
    "    y_test_e = label_binarize(y_test, classes = np.unique(y_true))\n",
    "\n",
    "    # Compute ROC Curve and AUC for each class\n",
    "    fpr = dict()\n",
    "    tpr = dict()\n",
    "    roc_auc = dict()\n",
    "    for i in range(y_test_e.shape[1]):\n",
    "        fpr[i], tpr[i], _ = roc_curve(y_test_e[:,i], y_pred[:,i])\n",
    "        roc_auc[i] = auc(fpr[i], tpr[i])\n",
    "    for k in roc_auc.keys():\n",
    "        if roc_auc[k] != np.nan:\n",
    "            auc_validations[k].append(roc_auc[k])\n",
    "\n",
    "    if T==19:\n",
    "        log_reg = plot_confusion_matrix(confusion_matrix(y_test, y_pred_b), classes = [\"Sick\", \"Healthy\", \"Follow\"], fname = r\"results/log_reg.png\")\n",
    "        print(confusion_matrix(y_test, y_pred_b))\n",
    "        print(classification_report(y_test, y_pred_b))\n",
    "\n",
    "##Print Results\n",
    "print_message(\"Logistic Regression\")\n",
    "print('\\n'+\"After {} Trials:\".format(T+1))\n",
    "for k in auc_validations.keys():\n",
    "    print(\"AUC {}: {}\".format(unique_labs[k], round(np.mean(auc_validations[k]),4)))\n",
    "\n",
    "##########################################################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Figure 4, Confusion Matrix](results/log_reg.png)\n",
    "\n",
    "#### Figure 4. Confusion Matrix of Logistic Regression.\n",
    "\n",
    "Logistic regression is a standard model used in microbiome analysis. This figure identifies the samples in the test set and identifies their predicted and real values. For instance, their are 14 \"Follow-up\" samples in the test dataset. 13 of them are predicted correctly and 1 are predicted wrong (predicted as 1 healthy). This model had the best AUC compared to the other methods so far. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "############################\n",
      "#Comparison Results for K=2#\n",
      "############################\n",
      "Result for K = 2\n",
      "Log,RFC: 0.4208\n",
      "Log,KMeans: -0.0141\n",
      "Log,Lin: 0.8131\n",
      "RFC,KMeans: -0.0122\n",
      "RFC,Lin: 0.4067\n",
      "KMeans,Lin: -0.006\n",
      "\n",
      "\n",
      "############################\n",
      "#Comparison Results for K=3#\n",
      "############################\n",
      "Result for K = 3\n",
      "Log,RFC: 0.4771\n",
      "Log,KMeans: 0.4106\n",
      "Log,Lin: 0.8221\n",
      "RFC,KMeans: 0.2265\n",
      "RFC,Lin: 0.4567\n",
      "KMeans,Lin: 0.3951\n",
      "\n",
      "\n",
      "############################\n",
      "#Comparison Results for K=4#\n",
      "############################\n",
      "Result for K = 4\n",
      "Log,RFC: 0.4771\n",
      "Log,KMeans: 0.3626\n",
      "Log,Lin: 0.8488\n",
      "RFC,KMeans: 0.2208\n",
      "RFC,Lin: 0.448\n",
      "KMeans,Lin: 0.3367\n",
      "\n",
      "\n",
      "############################\n",
      "#Comparison Results for K=5#\n",
      "############################\n",
      "Result for K = 5\n",
      "Log,RFC: 0.4745\n",
      "Log,KMeans: 0.1707\n",
      "Log,Lin: 0.8251\n",
      "RFC,KMeans: 0.1215\n",
      "RFC,Lin: 0.4245\n",
      "KMeans,Lin: 0.1548\n",
      "\n",
      "\n",
      "############################\n",
      "#Comparison Results for K=6#\n",
      "############################\n",
      "Result for K = 6\n",
      "Log,RFC: 0.4911\n",
      "Log,KMeans: 0.1917\n",
      "Log,Lin: 0.8384\n",
      "RFC,KMeans: 0.1625\n",
      "RFC,Lin: 0.4509\n",
      "KMeans,Lin: 0.1728\n",
      "\n",
      "\n",
      "############################\n",
      "#Comparison Results for K=7#\n",
      "############################\n",
      "Result for K = 7\n",
      "Log,RFC: 0.4489\n",
      "Log,KMeans: 0.1446\n",
      "Log,Lin: 0.8327\n",
      "RFC,KMeans: 0.1235\n",
      "RFC,Lin: 0.4218\n",
      "KMeans,Lin: 0.1284\n",
      "\n",
      "\n",
      "############################\n",
      "#Comparison Results for K=8#\n",
      "############################\n",
      "Result for K = 8\n",
      "Log,RFC: 0.5244\n",
      "Log,KMeans: 0.1407\n",
      "Log,Lin: 0.8295\n",
      "RFC,KMeans: 0.1298\n",
      "RFC,Lin: 0.4819\n",
      "KMeans,Lin: 0.1331\n",
      "\n",
      "\n",
      "############################\n",
      "#Comparison Results for K=9#\n",
      "############################\n",
      "Result for K = 9\n",
      "Log,RFC: 0.4326\n",
      "Log,KMeans: 0.1395\n",
      "Log,Lin: 0.8211\n",
      "RFC,KMeans: 0.1122\n",
      "RFC,Lin: 0.423\n",
      "KMeans,Lin: 0.123\n",
      "\n",
      "\n",
      "#############################\n",
      "#Comparison Results for K=10#\n",
      "#############################\n",
      "Result for K = 10\n",
      "Log,RFC: 0.5036\n",
      "Log,KMeans: 0.1329\n",
      "Log,Lin: 0.8433\n",
      "RFC,KMeans: 0.1054\n",
      "RFC,Lin: 0.4945\n",
      "KMeans,Lin: 0.1231\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "##########################################################\n",
    "##Comaprison to Methods\n",
    "##########################################################\n",
    "##K to try\n",
    "ks = [2,3,4,5,6,7,8,9,10]\n",
    "\n",
    "##Run pca take first 5 principle components\n",
    "X = PCA(n_components = 5).fit_transform(X)\n",
    "\n",
    "for K in ks:\n",
    "\n",
    "    ##Store Adjusted Rand Indices\n",
    "    rand_indexes = {\"Log,RFC\":0, \"Log,KMeans\":0, \"Log,Lin\":0, \"RFC,KMeans\":0, \"RFC,Lin\":0, \"KMeans,Lin\":0}\n",
    "\n",
    "    print_message(\"Comparison Results for K={}\".format(K))\n",
    "\n",
    "    ##Cross Validation by Repeat Trials\n",
    "    cnt = 1\n",
    "    for T in range(20):\n",
    "\n",
    "        ##Train-Test Split\n",
    "        X_train, X_test, y_train, y_test = TTS(X, y, test_size = 0.25)\n",
    "\n",
    "        ##Logistic Regression\n",
    "        lr_classifier = LogisticRegression()\n",
    "        y_pred_log = lr_classifier.fit(X_train, y_train).predict(X_test)\n",
    "\n",
    "        ##Random Forest\n",
    "        rfc = RFC(n_estimators=30, n_jobs = 5)\n",
    "        rfc.fit(X_train, y_train)\n",
    "        y_pred_rf = rfc.predict(X_test)\n",
    "\n",
    "        ##KMeans\n",
    "        ##Assigns new data to the nearest centroid\n",
    "        kmeans = KMeans(n_clusters = K)\n",
    "        kmeans.fit(X_train, y_train)\n",
    "        y_pred_km = kmeans.predict(X_test)\n",
    "\n",
    "        ##Linear SVM\n",
    "        classifier = OneVsRestClassifier(svm.SVC(kernel='linear', probability=True))\n",
    "        y_pred_lin = classifier.fit(X_train, y_train).predict(X_test)\n",
    "\n",
    "        rand_indexes[\"Log,RFC\"] += adjusted_rand_score(y_pred_log, y_pred_rf)\n",
    "        rand_indexes[\"Log,KMeans\"] += adjusted_rand_score(y_pred_log, y_pred_km)\n",
    "        rand_indexes[\"Log,Lin\"] += adjusted_rand_score(y_pred_log, y_pred_lin)\n",
    "        rand_indexes[\"RFC,KMeans\"] += adjusted_rand_score(y_pred_rf, y_pred_km)\n",
    "        rand_indexes[\"RFC,Lin\"] += adjusted_rand_score(y_pred_rf, y_pred_lin)\n",
    "        rand_indexes[\"KMeans,Lin\"] += adjusted_rand_score(y_pred_km, y_pred_lin)\n",
    "        cnt += 1\n",
    "\n",
    "    ##Print Result\n",
    "    print(\"Result for K = {}\".format(K))\n",
    "    for key in rand_indexes.keys():\n",
    "        print(\"{}: {}\".format(key, round(rand_indexes[key]/cnt, 4)))\n",
    "    print(\"\\n\")\n",
    "\n",
    "##########################################################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
